# Git


# SHA == commit_id (например, b4b3fb6d0593d425b836cfa044b1b20721a45fcb)

# Команды
## Документация по командам
git help
	<command_name>	# описание конкретной команды

# Задать конфигурацию Git
git config
	--list					# перечень параметров
	--global				# для всех проектов на компьютере
		user.name "Igor Polyakov"
		user.email igor_polyakov@phystech.edu
		color.ui true	# раскрасить сообщения Git в терминале
		alias.<cmd> \ "diff $1 $2 --stat -- . | wc -l"	# создание новых команд
		alias.st status	# аббревиатура для команды

## Создать контроль версий (создать хранилище ./.git/ в выбранной папке)
git init

## Удалённые репозитории
git remote
	add <name> <address>								# создать удалённый репозиторий
	add origin https://github.com/noggatur/new_repo.git	# на GitHub
	-v													# показать удалённый репозиторий
	rm <name>											# удалить удалённый репозиторий
	show origin											# показать текущее состояние веток
	prune origin										# убрать ветки удалённые с сервера

git clone
	<address>	# копирует репозиторий в текущий каталог

## Посмотреть изменения в системе
git status

## Посмотреть историю коммитов
git log
	-n <num>			# num коммитов
	--since=2016-09-23	# все коммиты, начиная с указанной даты
	--until=2016-09-23	# все коммиты, до указанной даты
		1.day.ago	# minute, hour, month, week
	--author="Igor"		# все коммиты указанного автора
	--grep="smth"		# поиск по коммитам через регулярное выражение
	HEAD				# последний коммит
	--pretty=oneline	# хэш и сообщение
	--pretty=format:"%h %ad- %s [%an]"	# произвольный формат коммитов
		%ad	# имя автора
		%an	# дата (автора)
		%h	# хэш
		%s	# сообщение
		%d	# ссылки
	-p		# добавляет данные из diff
	--stat	# добавляется информация о количестве изменений в коммите
	--graph	# графическое представление коммитов

## Посмотреть изменения
git diff	# все
	<file || branch>			# в конкретном файле
	$1 $2 --stat -- . | wc -l	# количество изменений
	--staged					# изменения в добавленных (перед коммитом) файлах
	--color-words				# показывает изменения прямо в строчке
	HEAD~5						# по сравнению с 5м с конца коммитом
	HEAD^..HEAD					# сравнение последнего с предпоследним
	<SHA_1>..<SHA_2>			# сравнение одного с другим

# Посмотреть, кто написал каждую строку в файле
git blame <file>
	--date short	# короткая запись даты

## Принять изменения (отслеживать изменения в файлах)
git add
	<file>	# в файле
	.		# в текущей папке
	--all	# все файлы
	"*.txt"	# во всех файлах проекта с расширением txt
	*.txt	# во всех файлах текущей папки с расширением txt

## Удалить файл и принять это изменение
git rm <file>	# работают те же обозначения, что и для add
	--cached <file>	# удалить только из отслеживания изменений

## Переместить файл и принять это изменение
git mv <путь_1/к/файлу> <путь_2/к/файлу>

## Закоммитить изменения (сохранить версию) и описать их
git commit -m "Commit message"
	--amend -m "Commit message"			# изменить коммит (если есть изменения) с указанным сообщением
	--amend -m "Amended commit message"	# изменить сообщение коммита (если нет изменений — проверить соблюдение условия !)
	-a									# добавить изменения в отслеживаемых файлах
### Коммиты желательно писать в настоящем времени
### Придерживаться одних и тех же тегов (кодированию изменений)
### Изменения следует описывать максимально конкретно
### Коммиты могут содержать довольно большое описание. В этом случае важно написать краткое пояснение, а затем более развёрнутое через 1 строчку

# Маркировка
git tag	# список маркеров
	-a <tag_name> -m "Tag message."	# добавить маркер

## HEAD — указатель на текущий коммит текущей ветки

## Передвинуть указатель назад
git reset
	<file>				# выкинуть файл из истории
	HEAD <file>			# отменить принятое изменение
	--soft <SHA || HEAD^>	# не меняет ни изменения, ни рабочую папку
	--mixed <SHA || HEAD^>	# меняет только изменения, но не рабочую папку
	--hard <SHA || HEAD^>	# меняет всё
## перед использованием этой команды правильно будет скопировать данные о последних 3х коммитах

## Удалить неотслеживаемые изменения
git clean
	-n	# проверить, что будет удаляться
	-f	# удалить

# Ветки
git branch	# посмотреть имеющиеся ветки
	<branch_name>		# создать ветку
	-d <branch_name>	# удалить ветку
	-D <branch_name>	# удалить ветку в локальном репозитории
	-r					# список удалённых веток

## Перейти к определённой версии
git checkout
	<file || SHA || branch || tag>			# перейти к версию файла, коммита или ветки
	-- <file>										# перейти к последней версии файла, оставаясь на той же ветке
	<SHA || part_of_the_commit_id> -- <file>	# вернуться к определённой версии файла. после этого необходимо сделать следующее:
		git reset HEAD <file>
		git checkout -- <file>
	-b <branch_name>								# создать и перейти в ветку

# Слить текущую ветку с другой веткой
git merge <branch_name>

## Вернуться к коммиту
git revert <SHA || part_of_the_commit_id>

## Запилить последнюю версию проекта на GitHub
git push
	<name> <branch>
	<name> <local_branch>:<remote_branch>
	-u origin master	# после этого можно просто git push
	origin :<branch>	# удалить ветку в удалённом репозитории
	--tags				# залить теги на сервер
### GitHub не заботится о контроле доступа к репозиторию.
### Есть альтернативные варианты репозиториев: BitBicket, Gitosis, Gitorious.
### В последних 2 реализован контроль доступа.

# Загрузить последние изменения с сервера и слить с текущей веткой
git pull
	<name> <branch>	# из ветки <branch>

# Загрузить последние изменения с сервера, но не сливать с веткой
git fetch	# для всех веток
	<name> <branch>	# для ветки <branch>

# Вставить изменения перед текущими изменениями
git rebase	# выполняется после git fetch
	<branch>	# из ветки <branch>
	--continue	# продолжить после разрешения конфликта

## Скрыть изменения с последнего коммита
git stash
## И обратно
git stash pop


# Игнорирование файлов
## Информация об игнорируемых файлах содержится в файле проекта .gitignore
## В нём перечисляются все файлы и папки
## Кроме того, можно задавать регулярные выражения с помощью символов
*, ?, [aeiou], [0-9]
## !этот_файл_не_игнорируется.html
## Строчные комментарии начинаются с символа #
## В проекте следует игнорировать
##   - скомпилированный код
##   - архивы
##   - логи и базы данных
##   - файлы, сгенерированные операционной системой
##   - файлы, загруженные пользователем
## Гобальное игнорирование:
git config --global core.excludesfile ~/.gitignore_global
### По умолчанию, Git игнорирует пустые папки (следит только за файлами). Если же нужно создать пустую папку, то в неё также нужно добавить файл .gitkeep
## Можно исключить файл также в файле ./.git/info/exclude
## Это исключение будет доступно только на одной машине, в отличие от информации в .gitignore


# Дополнительные фишки
## Настройка автозаполнения в Git
curl -OL http://github.com/git/git/raw/master/contrib/completion/git-completion.bash
mv ~/git-completion.bash ~/.git-completion.bash
### Прописать в .bash_profile
if [ -f ~/.git-completion.bash ]; then
	sourse ~/.git-completion.bash
fi

# Мои команды
## Время создания коммита
git show -s --date=iso-strict-local --pretty=format:'%ad' <SHA>


# Источники
# [V] https://try.github.io (введение в Git)
# [ ] https://www.codeschool.com/learn/git (практический курс)
# [ ] https://www.lynda.com/Git-tutorials/Git-Essential-Training/100222-2.html (теоретический курс)
# [ ] https://git-scm.com/book/en/v2 (лучшая книжка по Git)
# [ ] https://git-scm.com (графический интерфейс)
# [ ] https://desktop.github.com (полезное приложение)
# [ ] https://github.com/github/gitignore (про игнорирование файлов)
# [ ] https://help.github.com/articles/ignoring-files (про игнорирование файлов)
# [ ] https://help.github.com/articles/set-up-git (настроить Git так, чтобы не вводить пароль при обмене данными с сервером)